#!/usr/bin/env python3

import os
import sys
import subprocess
from pathlib import Path

class Colors:
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    END = '\033[0m'
    BOLD = '\033[1m'

def print_header(text):
    print(f"\n{Colors.HEADER}{Colors.BOLD}=== {text} ==={Colors.END}")

def print_success(text):
    print(f"{Colors.GREEN}✓ {text}{Colors.END}")

def print_info(text):
    print(f"{Colors.BLUE}→ {text}{Colors.END}")

def print_warning(text):
    print(f"{Colors.YELLOW}⚠ {text}{Colors.END}")

def print_error(text):
    print(f"{Colors.RED}✗ {text}{Colors.END}")

def get_workspace_dir():
    """Find or ask for workspace directory"""
    common_workspaces = [
        os.path.expanduser("~/workspace"),
        os.path.expanduser("~/projects"),
        os.path.expanduser("~/code"),
        os.path.expanduser("~/dev"),
        os.getcwd()
    ]

    existing_workspaces = [ws for ws in common_workspaces if os.path.isdir(ws)]

    if existing_workspaces:
        print_header("Workspace Selection")
        print("Found these potential workspaces:")
        for i, ws in enumerate(existing_workspaces, 1):
            print(f"  {i}. {ws}")
        print(f"  {len(existing_workspaces) + 1}. Enter custom path")

        while True:
            try:
                choice = input(f"\nSelect workspace (1-{len(existing_workspaces) + 1}): ").strip()
                if choice.isdigit():
                    choice = int(choice)
                    if 1 <= choice <= len(existing_workspaces):
                        return existing_workspaces[choice - 1]
                    elif choice == len(existing_workspaces) + 1:
                        break
                print_error("Invalid choice, try again")
            except KeyboardInterrupt:
                print("\nCancelled.")
                sys.exit(0)

    # Custom path input
    while True:
        workspace = input("Enter workspace path: ").strip()
        if not workspace:
            continue
        workspace = os.path.expanduser(workspace)
        if os.path.isdir(workspace):
            return workspace
        print_error(f"Directory doesn't exist: {workspace}")

def get_project_info():
    """Get project name and type"""
    print_header("Project Information")

    while True:
        name = input("Project name: ").strip()
        if name and name.replace('_', '').replace('-', '').isalnum():
            break
        print_error("Invalid name. Use letters, numbers, hyphens, and underscores only.")

    print("\nProject types:")
    types = [
        ("c", "C project (.c files, gcc)"),
        ("cpp", "C++ project (.cpp files, g++)"),
        ("mixed", "Mixed C/C++ project"),
        ("asm", "Assembly project (.s/.asm files)")
    ]

    for i, (key, desc) in enumerate(types, 1):
        print(f"  {i}. {desc}")

    while True:
        try:
            choice = input(f"\nSelect type (1-{len(types)}): ").strip()
            if choice.isdigit():
                choice = int(choice)
                if 1 <= choice <= len(types):
                    return name, types[choice - 1][0]
            print_error("Invalid choice, try again")
        except KeyboardInterrupt:
            print("\nCancelled.")
            sys.exit(0)

def get_build_system():
    """Choose build system"""
    print_header("Build System")

    systems = [
        ("make", "Makefile (simple, traditional)"),
        ("cmake", "CMake (modern, cross-platform)"),
        ("autocc", "autocc (minimal, fast and smart5)")
        ("manual", "No build system (manual compilation)")
    ]

    for i, (key, desc) in enumerate(systems, 1):
        print(f"  {i}. {desc}")

    while True:
        try:
            choice = input(f"\nSelect build system (1-{len(systems)}): ").strip()
            if choice.isdigit():
                choice = int(choice)
                if 1 <= choice <= len(systems):
                    return systems[choice - 1][0]
            print_error("Invalid choice, try again")
        except KeyboardInterrupt:
            print("\nCancelled.")
            sys.exit(0)

def create_c_main():
    return '''#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[]) {
    printf("Hello, World!\\n");
    return 0;
}
'''

def create_cpp_main():
    return '''#include <iostream>

int main(int argc, char *argv[]) {
    std::cout << "Hello, World!" << std::endl;
    return 0;
}
'''

def create_asm_main():
    return '''.section .data
    msg: .ascii "Hello, World!\\n"
    msg_len = . - msg

.section .text
    .global _start

_start:
    # write system call
    mov $1, %rax        # sys_write
    mov $1, %rdi        # stdout
    mov $msg, %rsi      # message
    mov $msg_len, %rdx  # length
    syscall

    # exit system call
    mov $60, %rax       # sys_exit
    mov $0, %rdi        # exit status
    syscall
'''

def create_makefile(project_name, project_type):
    if project_type == "c":
        return f'''CC = gcc
CFLAGS = -Wall -Wextra -std=c99 -g
TARGET = {project_name}
SRCDIR = src
OBJDIR = build
SOURCES = $(wildcard $(SRCDIR)/*.c)
OBJECTS = $(SOURCES:$(SRCDIR)/%.c=$(OBJDIR)/%.o)

.PHONY: all clean run debug

all: $(OBJDIR) $(TARGET)

$(TARGET): $(OBJECTS)
\t$(CC) $(OBJECTS) -o $@

$(OBJDIR)/%.o: $(SRCDIR)/%.c
\t$(CC) $(CFLAGS) -c $< -o $@

$(OBJDIR):
\tmkdir -p $(OBJDIR)

clean:
\trm -rf $(OBJDIR) $(TARGET)

run: $(TARGET)
\t./$(TARGET)

debug: CFLAGS += -DDEBUG
debug: $(TARGET)

install: $(TARGET)
\tcp $(TARGET) /usr/local/bin/
'''
    elif project_type == "cpp":
        return f'''CXX = g++
CXXFLAGS = -Wall -Wextra -std=c++17 -g
TARGET = {project_name}
SRCDIR = src
OBJDIR = build
SOURCES = $(wildcard $(SRCDIR)/*.cpp)
OBJECTS = $(SOURCES:$(SRCDIR)/%.cpp=$(OBJDIR)/%.o)

.PHONY: all clean run debug

all: $(OBJDIR) $(TARGET)

$(TARGET): $(OBJECTS)
\t$(CXX) $(OBJECTS) -o $@

$(OBJDIR)/%.o: $(SRCDIR)/%.cpp
\t$(CXX) $(CXXFLAGS) -c $< -o $@

$(OBJDIR):
\tmkdir -p $(OBJDIR)

clean:
\trm -rf $(OBJDIR) $(TARGET)

run: $(TARGET)
\t./$(TARGET)

debug: CXXFLAGS += -DDEBUG
debug: $(TARGET)

install: $(TARGET)
\tcp $(TARGET) /usr/local/bin/
'''
    elif project_type == "asm":
        return f'''AS = as
LD = ld
TARGET = {project_name}
SRCDIR = src
OBJDIR = build
SOURCES = $(wildcard $(SRCDIR)/*.s)
OBJECTS = $(SOURCES:$(SRCDIR)/%.s=$(OBJDIR)/%.o)

.PHONY: all clean run

all: $(OBJDIR) $(TARGET)

$(TARGET): $(OBJECTS)
\t$(LD) $(OBJECTS) -o $@

$(OBJDIR)/%.o: $(SRCDIR)/%.s
\t$(AS) $< -o $@

$(OBJDIR):
\tmkdir -p $(OBJDIR)

clean:
\trm -rf $(OBJDIR) $(TARGET)

run: $(TARGET)
\t./$(TARGET)

install: $(TARGET)
\tcp $(TARGET) /usr/local/bin/
'''

def create_autocc(project_name, project_type):
    if project_type == "c":
        return f'''[compilers]
as = 'nasm'
cc = 'clang'
cxx = 'clang++'
[features]
use_pch = true
[paths]
exclude_patterns = []
include_dirs = []
[project]
build_dir = 'build'
default_target = 'main'
[[targets]]
cflags = '-std=c11'
cxxflags = '-std=c++20'
exclude_patterns = []
external_libs = []
main_file = './src/main.c'
name = 'main'
output_name = 'main'
sources = [ './src/main.c' ]
'''
    elif project_type == "cpp":
        return f'''[compilers]
as = 'nasm'
cc = 'clang'
cxx = 'clang++'
[features]
use_pch = true
[paths]
exclude_patterns = []
include_dirs = []
[project]
build_dir = 'build'
default_target = 'main'
[[targets]]
cflags = '-std=c11'
cxxflags = '-std=c++20'
exclude_patterns = []
external_libs = []
main_file = './src/main.cpp'
name = 'main'
output_name = 'main'
sources = [ './src/main.cpp' ]
'''
    elif project_type == "asm":
        return f'''[compilers]
as = 'as'
cc = 'clang'
cxx = 'clang++'
[features]
use_pch = true
[paths]
exclude_patterns = []
include_dirs = []
[project]
build_dir = 'build'
default_target = 'main'
[[targets]]
cflags = '-std=c11'
cxxflags = '-std=c++20'
exclude_patterns = []
external_libs = []
main_file = './src/main.s'
name = 'main'
output_name = 'main'
sources = [ './src/main.s' ]
'''

def create_cmake(project_name, project_type):
    if project_type == "c":
        return f'''cmake_minimum_required(VERSION 3.10)
project({project_name} C)

set(CMAKE_C_STANDARD 99)
set(CMAKE_C_FLAGS "${{CMAKE_C_FLAGS}} -Wall -Wextra")

file(GLOB SOURCES "src/*.c")

add_executable({project_name} ${{SOURCES}})

# Debug configuration
set(CMAKE_BUILD_TYPE Debug)
'''
    elif project_type == "cpp":
        return f'''cmake_minimum_required(VERSION 3.10)
project({project_name} CXX)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_FLAGS "${{CMAKE_CXX_FLAGS}} -Wall -Wextra")

file(GLOB SOURCES "src/*.cpp")

add_executable({project_name} ${{SOURCES}})

# Debug configuration
set(CMAKE_BUILD_TYPE Debug)
'''

def create_project_structure(workspace, name, project_type, build_system):
    """Create the project directory structure"""
    project_path = Path(workspace) / name

    if project_path.exists():
        print_error(f"Project '{name}' already exists!")
        return None

    print_info(f"Creating project: {project_path}")

    # Create directories
    project_path.mkdir()
    (project_path / "src").mkdir()

    # Create main file
    if project_type == "c":
        main_file = project_path / "src" / "main.c"
        main_content = create_c_main()
    elif project_type == "cpp":
        main_file = project_path / "src" / "main.cpp"
        main_content = create_cpp_main()
    elif project_type == "mixed":
        # Create both files
        (project_path / "src" / "main.c").write_text(create_c_main())
        main_file = project_path / "src" / "main.cpp"
        main_content = create_cpp_main()
    elif project_type == "asm":
        main_file = project_path / "src" / "main.s"
        main_content = create_asm_main()

    main_file.write_text(main_content)
    print_success(f"Created {main_file.name}")

    # Create build system files
    if build_system == "make":
        makefile = project_path / "Makefile"
        makefile.write_text(create_makefile(name, project_type))
        print_success("Created Makefile")
    elif build_system == "cmake":
        cmake_file = project_path / "CMakeLists.txt"
        cmake_file.write_text(create_cmake(name, project_type))
        print_success("Created CMakeLists.txt")
    elif build_system == "autocc":
        autocc_file = project_path / "autocc.toml"
        autocc_file.write_text(create_autocc(name, project_type))
        print_success("Created autocc.toml")

    # Create .gitignore
    gitignore = project_path / ".gitignore"
    gitignore_content = '''# Build artifacts
build/
*.o
*.obj
*.exe
*.out
a.out

# IDE files
.vscode/
.idea/
*.swp
*.swo

# System files
.DS_Store
Thumbs.db
'''
    gitignore.write_text(gitignore_content)
    print_success("Created .gitignore")

    # Create README
    readme = project_path / "README.md"
    readme_content = f'''# {name}

## Build

'''
    if build_system == "make":
        readme_content += '''```bash
make
```

## Run

```bash
make run
```

## Clean

```bash
make clean
```
'''
    elif build_system == "cmake":
        readme_content += '''```bash
mkdir build && cd build
cmake ..
make
```

## Run

```bash
./''' + name + '''
```
'''
    else:
        if project_type == "c":
            readme_content += f"```bash\ngcc src/main.c -o {name}\n```"
        elif project_type == "cpp":
            readme_content += f"```bash\ng++ src/main.cpp -o {name}\n```"

    readme.write_text(readme_content)
    print_success("Created README.md")

    return project_path

def main():
    print_header("C/C++ Project Wizard")
    print("This wizard will help you create a new C/C++ project quickly!")

    try:
        # Get project details
        workspace = get_workspace_dir()
        name, project_type = get_project_info()
        build_system = get_build_system()

        # Confirm settings
        print_header("Project Summary")
        print(f"Name: {Colors.BOLD}{name}{Colors.END}")
        print(f"Type: {Colors.BOLD}{project_type.upper()}{Colors.END}")
        print(f"Build: {Colors.BOLD}{build_system}{Colors.END}")
        print(f"Location: {Colors.BOLD}{workspace}/{name}{Colors.END}")

        confirm = input(f"\n{Colors.YELLOW}Create project? (Y/n): {Colors.END}").strip().lower()
        if confirm and confirm != 'y' and confirm != 'yes':
            print("Cancelled.")
            return

        # Create project
        print_header("Creating Project")
        project_path = create_project_structure(workspace, name, project_type, build_system)

        if project_path:
            print_header("Success!")
            print_success(f"Project '{name}' created successfully!")
            print_info(f"Location: {project_path}")

            # Ask if user wants to open in editor
            open_editor = input(f"\n{Colors.YELLOW}Open in Zed? (Y/n): {Colors.END}").strip().lower()
            if not open_editor or open_editor in ['y', 'yes']:
                try:
                    subprocess.run(['zed', str(project_path)], check=True)
                    print_success("Opened in Zed!")
                except (subprocess.CalledProcessError, FileNotFoundError):
                    print_warning("Could not open Zed. You can open manually:")
                    print(f"  cd {project_path} && zed .")

            print(f"\n{Colors.BLUE}Quick commands:{Colors.END}")
            print(f"  cd {project_path}")
            if build_system == "make":
                print(f"  make && .//{name}")
            elif build_system == "cmake":
                print(f"  mkdir build && cd build && cmake .. && make")

    except KeyboardInterrupt:
        print("\n\nCancelled.")
        sys.exit(0)
    except Exception as e:
        print_error(f"Error: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
